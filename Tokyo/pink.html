<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>東京花見 - Pink Sakura Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* V3 修改：背景改為明確的粉色漸層 */
            background: linear-gradient(135deg, #fff0f5 0%, #ffe6ee 100%);
            font-family: 'Noto Serif JP', serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding-left: 8vw;
            color: #7a4a58; /* V3 修改：文字顏色改為暖棕紅色，對比粉背景 */
        }

        .vertical-text {
            writing-mode: vertical-rl;
            font-size: 1.2rem;
            letter-spacing: 0.5em;
            position: absolute;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.7;
            border-right: 1px solid rgba(168, 100, 120, 0.2);
            padding-right: 20px;
            font-weight: 500;
        }

        h1 {
            font-size: 6rem;
            font-weight: 700;
            margin: 0;
            line-height: 1;
            /* V3 修改：標題漸層更鮮豔的粉色 */
            background: linear-gradient(45deg, #ff5e8e, #ff9eb5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 4px 15px rgba(255, 94, 142, 0.3));
            opacity: 0;
            transform: translateY(20px);
        }

        h2 {
            font-size: 1.3rem;
            font-weight: 500;
            letter-spacing: 0.3em;
            margin-top: 1rem;
            margin-bottom: 3rem;
            color: #a86478; /* V3 修改：副標題顏色 */
            opacity: 0;
            transform: translateY(20px);
        }

        .cta-container {
            pointer-events: auto;
            opacity: 0;
            transform: translateY(20px);
        }

        .cta-button {
            padding: 15px 45px;
            background: rgba(255, 255, 255, 0.5);
            /* V3 修改：按鈕邊框和文字更粉 */
            border: 1px solid #ff8fab;
            color: #d65d7a;
            font-size: 1rem;
            font-weight: 500;
            font-family: 'Noto Serif JP', serif;
            cursor: pointer;
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
            border-radius: 2px;
            letter-spacing: 0.1em;
            box-shadow: 0 4px 15px rgba(255, 143, 171, 0.2);
        }

        .cta-button:hover {
            background: #fff;
            border-color: #ff5e8e;
            color: #ff5e8e;
            box-shadow: 0 6px 25px rgba(255, 94, 142, 0.3);
            transform: translateY(-2px);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d65d7a;
            font-size: 1rem;
            letter-spacing: 3px;
            z-index: 10;
            transition: opacity 0.5s;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            h1 { font-size: 3.5rem; }
            #ui-layer { align-items: center; padding-left: 0; text-align: center; }
            .vertical-text { display: none; }
        }
    </style>
</head>
<body>

    <div id="loading">東京の桜色を読み込み中...</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="vertical-text">満開の季節へ</div>
        <h1>桜花爛漫</h1>
        <h2>TOKYO PINK SEASON</h2>
        <div class="cta-container">
            <button class="cta-button">お花見を予約する</button>
        </div>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // V3 修改：場景背景色和迷霧色改為淡粉色
        const pinkBgColor = new THREE.Color(0xfff0f5); // Lavender Blush
        scene.background = pinkBgColor; 
        // 增加霧的濃度，讓遠處的花瓣更柔和地融入粉色背景
        scene.fog = new THREE.FogExp2(0xfff0f5, 0.015); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        // 稍微降低曝光，讓粉色更飽和
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        // --- V3 修改：燈光系統全面粉色化 ---
        // 環境光帶粉色調
        const ambientLight = new THREE.AmbientLight(0xffe6eb, 0.7);
        scene.add(ambientLight);

        // 主太陽光帶暖粉色
        const sunLight = new THREE.DirectionalLight(0xffd1dc, 1.5);
        sunLight.position.set(5, 10, 7);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; // 提高陰影品質
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.bias = -0.0005;
        scene.add(sunLight);

        // 輪廓光加強粉色
        const rimLight = new THREE.SpotLight(0xff69b4, 2.5); // Hot Pink
        rimLight.position.set(-5, 8, -5);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);
        
        // 底部補光 (反射光)
        const bounceLight = new THREE.PointLight(0xffc2d1, 1, 20);
        bounceLight.position.set(0, -5, 2);
        scene.add(bounceLight);

        // --- 幾何與材質 ---

        function createRealPetalGeometry() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0); 
            shape.bezierCurveTo(0.3, 0.1, 0.5, 0.6, 0.4, 1.0);
            shape.lineTo(0.1, 0.88); // 缺口稍微深一點
            shape.lineTo(-0.1, 0.88);
            shape.bezierCurveTo(-0.4, 1.0, -0.5, 0.6, 0, 0);

            const geometry = new THREE.ShapeGeometry(shape, 10); // 增加細分度
            
            const posAttribute = geometry.attributes.position;
            const vertexCount = posAttribute.count;
            const colors = [];
            
            // V3 關鍵修改：花瓣顏色定義
            // 中心點：深粉紅
            const centerColor = new THREE.Color(0xff5e8e); 
            // 邊緣：淺粉紅 (不再是白色！)
            const edgeColor = new THREE.Color(0xffcdda);   

            for (let i = 0; i < vertexCount; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                const z = posAttribute.getZ(i);

                // 彎曲度
                const newZ = z + (x * x * 0.8) + (Math.sin(y * 2.0) * 0.15);
                posAttribute.setZ(i, newZ);

                // 顏色漸層邏輯
                const alpha = Math.max(0, Math.min(1, y / 1.05));
                // 使用 easeIn Quad 讓深粉色區域稍微大一點
                const mixFactor = alpha * alpha; 
                const mixedColor = centerColor.clone().lerp(edgeColor, mixFactor);
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            geometry.translate(0, -0.1, 0); // 調整中心點
            return geometry;
        }

        const petalGeometry = createRealPetalGeometry();

        // V3 修改：花瓣材質調整
        const petalMaterial = new THREE.MeshPhysicalMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.98, // 稍微提高不透明度，讓顏色更實
            roughness: 0.35,
            metalness: 0.0,
            clearcoat: 0.3, // 增加光澤感
            clearcoatRoughness: 0.2,
            transmission: 0.15, // 降低透光度，避免粉色被洗掉
            thickness: 0.2,
            // 加入一點點基礎粉色發光，確保在暗處也是粉的
            emissive: 0x330011, 
            emissiveIntensity: 0.2
        });

        // --- 主花朵構建 ---
        const sakuraGroup = new THREE.Group();
        
        for (let i = 0; i < 5; i++) {
            const petal = new THREE.Mesh(petalGeometry, petalMaterial);
            petal.castShadow = true;
            petal.receiveShadow = true;
            
            const angle = (i / 5) * Math.PI * 2;
            const wrapper = new THREE.Group();
            wrapper.rotation.z = angle;
            
            // 調整花瓣姿態，使其更像盛開
            petal.position.set(0, 0.25, 0); 
            petal.rotation.x = 0.35; 
            
            wrapper.add(petal);
            sakuraGroup.add(wrapper);
        }

        function createStamens() {
            const stamenGroup = new THREE.Group();
            // V3 修改：花絲顏色改為深粉紅
            const filamentMat = new THREE.LineBasicMaterial({ color: 0xff6b88 }); 
            const antherGeom = new THREE.SphereGeometry(0.035, 8, 8);
            // V3 修改：花藥顏色改為暖金色
            const antherMat = new THREE.MeshStandardMaterial({ color: 0xffd000, roughness: 0.5 });

            for(let i=0; i<18; i++) {
                const height = 0.25 + Math.random() * 0.15;
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.08 + Math.random() * 0.06;
                
                const points = [];
                // 起點稍微提高
                points.push(new THREE.Vector3(radius * Math.cos(angle) * 0.5, radius * Math.sin(angle) * 0.5, 0.05));
                points.push(new THREE.Vector3(
                    (radius + 0.1) * Math.cos(angle), 
                    (radius + 0.1) * Math.sin(angle), 
                    height
                ));
                const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
                const filament = new THREE.Line(lineGeom, filamentMat);
                stamenGroup.add(filament);

                const anther = new THREE.Mesh(antherGeom, antherMat);
                anther.position.set(
                    (radius + 0.1) * Math.cos(angle),
                    (radius + 0.1) * Math.sin(angle),
                    height
                );
                stamenGroup.add(anther);
            }
            stamenGroup.position.z = 0.05;
            return stamenGroup;
        }

        const stamens = createStamens();
        sakuraGroup.add(stamens);

        sakuraGroup.rotation.x = 0.5;
        sakuraGroup.scale.set(0, 0, 0);
        sakuraGroup.position.set(2.5, 0, 0); 
        scene.add(sakuraGroup);

        // --- 櫻花雨 ---
        const PARTICLE_COUNT = 350; // 增加粒子數量
        const instancedPetals = new THREE.InstancedMesh(petalGeometry, petalMaterial, PARTICLE_COUNT);
        instancedPetals.castShadow = true;
        instancedPetals.receiveShadow = true;
        
        const dummy = new THREE.Object3D();
        const particlesData = [];
        const rangeX = 30;
        const rangeY = 25;
        const rangeZ = 15;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * rangeX;
            const y = (Math.random() - 0.5) * rangeY;
            const z = (Math.random() - 0.5) * rangeZ;

            dummy.position.set(x, y, z);
            dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            const scale = 0.4 + Math.random() * 0.5;
            dummy.scale.set(scale, scale, scale);
            dummy.updateMatrix();
            instancedPetals.setMatrixAt(i, dummy.matrix);

            particlesData.push({
                position: new THREE.Vector3(x, y, z),
                rotation: new THREE.Euler(Math.random(), Math.random(), Math.random()),
                tumbleSpeed: {
                    x: Math.random() * 0.03 + 0.01,
                    y: Math.random() * 0.03 + 0.01,
                    z: Math.random() * 0.01
                },
                fallSpeed: 0.015 + Math.random() * 0.025,
                swayAmplitude: 0.02 + Math.random() * 0.03,
                swayFrequency: 0.8 + Math.random() * 1.5,
                timeOffset: Math.random() * 100
            });
        }
        instancedPetals.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(instancedPetals);

        // --- 互動與動畫 ---
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        window.onload = () => {
            const tl = gsap.timeline();
            gsap.to("#loading", { opacity: 0, duration: 0.5, onComplete: () => document.getElementById('loading').style.display = 'none' });

            tl.to(sakuraGroup.scale, { x: 1.8, y: 1.8, z: 1.8, duration: 2.2, ease: "elastic.out(1, 0.75)" })
              .to(sakuraGroup.rotation, { y: -0.4, duration: 2.5, ease: "power2.out" }, "<")
              .to(".vertical-text", { opacity: 0.7, duration: 1 }, "-=1.2")
              .to("h1", { opacity: 1, y: 0, duration: 1.2, ease: "power3.out" }, "-=1")
              .to("h2", { opacity: 1, y: 0, duration: 1, ease: "power3.out" }, "-=1")
              .to(".cta-container", { opacity: 1, y: 0, duration: 0.8 }, "-=0.6");
        };

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 主花朵動態
            sakuraGroup.rotation.z += 0.0008; 
            // 視差互動
            const targetRotateY = mouseX * 0.25;
            const targetRotateX = mouseY * 0.15;
            sakuraGroup.rotation.y += (targetRotateY - sakuraGroup.rotation.y - 0.4) * 0.04;
            sakuraGroup.rotation.x += (targetRotateX - sakuraGroup.rotation.x + 0.5) * 0.04;

            // 櫻花雨動態
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const data = particlesData[i];
                data.position.y -= data.fallSpeed;
                
                // 風力計算 (加入一些隨機擾動)
                const noise = Math.sin(data.timeOffset + time) * 0.01;
                const wind = Math.sin(time * 0.4 + data.position.y * 0.08) * 0.015 + (mouseX * 0.04) + noise;
                
                data.position.x += wind + Math.sin(time * data.swayFrequency + data.timeOffset) * data.swayAmplitude;
                data.position.z += Math.cos(time * 0.2 + data.timeOffset) * 0.005;

                data.rotation.x += data.tumbleSpeed.x;
                data.rotation.y += data.tumbleSpeed.y;
                data.rotation.z += data.tumbleSpeed.z;

                if (data.position.y < -12) {
                    data.position.y = 15;
                    data.position.x = (Math.random() - 0.5) * rangeX;
                    data.position.z = (Math.random() - 0.5) * rangeZ; 
                }
                if (data.position.x > 18) data.position.x = -18;
                if (data.position.x < -18) data.position.x = 18;

                dummy.position.copy(data.position);
                dummy.rotation.copy(data.rotation);
                dummy.updateMatrix();
                instancedPetals.setMatrixAt(i, dummy.matrix);
            }
            instancedPetals.instanceMatrix.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(window.innerWidth < 768) {
                sakuraGroup.position.set(0, 1.5, 0);
                sakuraGroup.scale.set(1.3, 1.3, 1.3);
            } else {
                sakuraGroup.position.set(2.5, 0, 0);
                sakuraGroup.scale.set(1.8, 1.8, 1.8);
            }
        });
        window.dispatchEvent(new Event('resize'));
    </script>
</body>
</html>
